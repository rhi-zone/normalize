{
  "info": {
    "description": "Headless agent orchestration layer",
    "title": "Moss API",
    "version": "0.1.0"
  },
  "openapi": "3.0.3",
  "paths": {
    "/anchor/find": {
      "get": {
        "description": "Find anchors matching a name in a file. List of AnchorMatch objects with locations and confidence scores",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter - \"function\", \"class\", \"variable\", \"method\", \"import\"",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for (supports fuzzy matching)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find anchors matching a name in a file",
        "tags": [
          "anchor"
        ]
      }
    },
    "/anchor/resolve": {
      "get": {
        "description": "Resolve a single anchor (raises if ambiguous or not found). Single best AnchorMatch AnchorNotFoundError: If no match found AmbiguousAnchorError: If multiple matches with equal confidence",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a single anchor (raises if ambiguous or not found)",
        "tags": [
          "anchor"
        ]
      }
    },
    "/cfg/build": {
      "post": {
        "description": "Build CFGs for all functions in a file. List of ControlFlowGraph objects for each function",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Build CFGs for all functions in a file",
        "tags": [
          "cfg"
        ]
      }
    },
    "/context/compile": {
      "post": {
        "description": "Compile context for the given files. CompiledContext with rendered views",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_paths": {
                    "description": "Files to include in context",
                    "type": "array"
                  },
                  "view_types": {
                    "description": "View types to generate (default: skeleton, dependencies)",
                    "type": "array"
                  }
                },
                "required": [
                  "file_paths"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Compile context for the given files",
        "tags": [
          "context"
        ]
      }
    },
    "/context/init": {
      "post": {
        "description": "Initialize the context host with default view providers. ContextHost instance",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize the context host with default view providers",
        "tags": [
          "context"
        ]
      }
    },
    "/dependencies/analyze": {
      "get": {
        "description": "Run full dependency analysis on the project. DependencyAnalysis with circular deps, god modules, orphans, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full dependency analysis on the project",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/extract": {
      "post": {
        "description": "Extract imports and exports from a file. DependencyInfo with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract imports and exports from a file",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/format": {
      "post": {
        "description": "Extract and format dependencies as readable text. Formatted string with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format dependencies as readable text",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dwim/analyze-intent": {
      "get": {
        "description": "Analyze a natural language query to find matching tools. Uses TF-IDF cosine similarity combined with keyword matching to find the best tools for a given description. List of ToolMatchResult sorted by confidence (highest first)",
        "parameters": [
          {
            "description": "Natural language description of what you want to do",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of suggestions to return",
            "in": "query",
            "name": "top_k",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze a natural language query to find matching tools",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/get-tool-info": {
      "get": {
        "description": "Get detailed information about a specific tool. ToolInfoResult or None if tool not found",
        "parameters": [
          {
            "description": "Tool name (can be alias or misspelled)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get detailed information about a specific tool",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/list-tools": {
      "get": {
        "description": "List all available tools with their metadata. List of ToolInfoResult with descriptions, keywords, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List all available tools with their metadata",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/resolve-tool": {
      "get": {
        "description": "Resolve a tool name to its canonical form. Handles exact matches, semantic aliases, and fuzzy matching for typos. ToolMatchResult with canonical name and confidence",
        "parameters": [
          {
            "description": "Tool name to resolve (may be misspelled or alias)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a tool name to its canonical form",
        "tags": [
          "dwim"
        ]
      }
    },
    "/git/commit": {
      "post": {
        "description": "Create a commit on the current shadow branch. CommitHandle referencing the new commit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "message": {
                    "description": "Commit message",
                    "type": "string"
                  }
                },
                "required": [
                  "message"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a commit on the current shadow branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git/create-branch": {
      "post": {
        "description": "Create an isolated shadow branch for agent work. ShadowBranch context manager",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Optional branch name (auto-generated if not provided)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create an isolated shadow branch for agent work",
        "tags": [
          "git"
        ]
      }
    },
    "/git/init": {
      "post": {
        "description": "Initialize shadow git for the project. ShadowGit instance for managing branches",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize shadow git for the project",
        "tags": [
          "git"
        ]
      }
    },
    "/health/analyze-structure": {
      "get": {
        "description": "Analyze structural code quality. StructuralAnalysis with hotspots and metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze structural code quality",
        "tags": [
          "health"
        ]
      }
    },
    "/health/analyze-tests": {
      "get": {
        "description": "Analyze test coverage structure. TestAnalysis with module-test mappings",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze test coverage structure",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check": {
      "get": {
        "description": "Run full health analysis on the project. ProjectStatus with health score, grade, and detailed metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full health analysis on the project",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-docs": {
      "get": {
        "description": "Check documentation health. DocCheckResult with coverage and issues",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check documentation health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-todos": {
      "get": {
        "description": "Check TODO tracking health. TodoCheckResult with tracked and orphaned TODOs",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check TODO tracking health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/summarize": {
      "get": {
        "description": "Generate a project summary. ProjectSummary with module information",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate a project summary",
        "tags": [
          "health"
        ]
      }
    },
    "/patch/apply": {
      "post": {
        "description": "Apply a patch to a file. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch to a file",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/apply-with-fallback": {
      "post": {
        "description": "Apply a patch with automatic text fallback. First tries AST-aware patching, falls back to text-based if that fails. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch with automatic text fallback",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/create": {
      "post": {
        "description": "Create a Patch object. Patch object ready for application",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_name": {
                    "description": "Name of the anchor to target",
                    "type": "string"
                  },
                  "content": {
                    "description": "New content for the patch",
                    "type": "string"
                  },
                  "kwargs": {
                    "description": "",
                    "type": "string"
                  },
                  "patch_type": {
                    "description": "Type of patch - \"insert\", \"replace\", \"delete\", \"wrap\"",
                    "type": "string"
                  }
                },
                "required": [
                  "patch_type",
                  "anchor_name",
                  "content",
                  "kwargs"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a Patch object",
        "tags": [
          "patch"
        ]
      }
    },
    "/skeleton/extract": {
      "post": {
        "description": "Extract skeleton from a Python file. List of Symbol objects representing the code structure",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file (relative to root or absolute)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract skeleton from a Python file",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/skeleton/format": {
      "post": {
        "description": "Extract and format skeleton as readable text. Formatted string representation of the skeleton",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  },
                  "include_docstrings": {
                    "default": true,
                    "description": "Whether to include docstrings in output",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format skeleton as readable text",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/validation/create-chain": {
      "post": {
        "description": "Create a standard Python validator chain. ValidatorChain configured for Python (syntax + ruff + pytest)",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a standard Python validator chain",
        "tags": [
          "validation"
        ]
      }
    },
    "/validation/validate": {
      "post": {
        "description": "Validate a Python file with the default chain. ValidationResult with any issues found",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to validate",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Validate a Python file with the default chain",
        "tags": [
          "validation"
        ]
      }
    }
  },
  "tags": [
    {
      "description": "API for code skeleton extraction. Extracts structural summaries of code (classes, functions, signatures) without implementation details.",
      "name": "skeleton"
    },
    {
      "description": "API for finding code locations using fuzzy anchors. Anchors identify code elements (functions, classes, variables) by name and type, with fuzzy matching support.",
      "name": "anchor"
    },
    {
      "description": "API for applying code patches. Supports AST-aware patching with automatic fallback to text-based patching when AST parsing fails.",
      "name": "patch"
    },
    {
      "description": "API for dependency analysis. Analyzes import/export relationships, detects circular dependencies, and provides coupling metrics.",
      "name": "dependencies"
    },
    {
      "description": "API for control flow graph analysis. Builds control flow graphs showing execution paths through functions.",
      "name": "cfg"
    },
    {
      "description": "API for code validation. Runs validators (syntax, linting, tests) and reports issues.",
      "name": "validation"
    },
    {
      "description": "API for shadow git operations. Provides atomic commit/rollback operations for safe code modifications.",
      "name": "git"
    },
    {
      "description": "API for context compilation. Compiles code views (skeletons, CFGs, dependencies) into structured context for AI consumption.",
      "name": "context"
    },
    {
      "description": "API for project health analysis. Provides comprehensive project health metrics and reports.",
      "name": "health"
    },
    {
      "description": "API for semantic tool routing and discovery. Provides fuzzy matching and semantic routing for tool discovery, making Moss interfaces robust against minor variations in how tools are invoked. Features: - Semantic aliases: map conceptual names to canonical tools - Fuzzy matching: handle typos and variations - TF-IDF cosine similarity: smarter semantic matching - Confidence scoring: know when to auto-correct vs suggest",
      "name": "dwim"
    }
  ]
}
